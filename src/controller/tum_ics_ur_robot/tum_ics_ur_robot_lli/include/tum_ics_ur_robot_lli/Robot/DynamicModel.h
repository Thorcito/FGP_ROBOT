/* Robot State Client class
 * Authors: Emmanuel Dean and Florian Bergner
 * email: dean@tum.de, florian.bergner@tum.de
 *
 * v1: 2015
 */
#ifndef UR_ROBOT_LLI_DYNAMICS_H
#define UR_ROBOT_LLI_DYNAMICS_H


#include<tumtools/Math/MathTools.h>
#include<tumtools/Math/ButterFilter2.h>


#include<tum_ics_ur_robot_lli/JointState.h>
#include<tum_ics_ur_robot_lli/Robot/KinematicModel.h>

#include<tum_ics_ur_robot_lli/RobotControllers/Controller.h>






namespace tum_ics_ur_robot_lli{
namespace Robot{

typedef Tum::Tools::Butter2 TButter2;
//typedef RobotTools::Butter2 TButter2;

/*!
 * \brief The DynamicModel class This class provides methods to compute useful dynamic models of the
 * UR robot, e.g. Direct dynamics, Robot regressor, M and C matrices, G vector, etc. This class uses
 * the dynamics parameters provided in the robot configuration file (config.ini).
 */

class DynamicModel: public Tum::Tools::MathTools
{
    // Member variables
public:

private:

    /*!
     * \brief m_errorString variable to store the text description of an error triggered in the class.
     */
    QString m_errorString;

    /*!
     * \brief m_error error flag, used for example to stop all the threads of the robotArm class.
     */
    bool m_error;

    /*!
     * \brief m_kinematicModel Kinematic model class with kinematic model functions and variables, e.g.
     * end-effector position wrt robot base and world, Jacobians, Homogeneous Transformations, etc.
     * Usually, the instantiation of this class is done in the RobotArm class, and pass it as pointer to
     * this class.
     */
    KinematicModel *m_kinematicModel;


    /*!
     * \brief m_lcm offsets for the center of masses (d and a variables from DH table). This offests
     * are defined in the robot configuration file (config.ini).
     */
    VectorDOFd m_lcm;

    /*!
     * \brief m_m masses of each robot link defined in the robot configuration file (config.ini).
     */
    VectorDOFd m_m;

    /*!
     * \brief m_inertia Array of inertia matrices of each link, defined in the robot configuration file (config.ini).
     */
    VVector6d m_inertia;

    /*!
     * \brief m_g gravitational acceleration magnitud, defined in the robot configuration file (config.ini).
     */
    double m_g;



    /*!
     * \brief m_q joint position in time t.
     */
    JointState m_q;     //jointState(t) --q,qp,qpp,tau--
    /*!
     * \brief m_q_1 joint position in time t-1.
     */
    JointState m_q_1;   //jointState(t-1)
    /*!
     * \brief m_q_2 joint position in time t-2.
     */
    JointState m_q_2;   //jointState(t-2)

    /*!
     * \brief m_qf filtered joint position in time t.
     */
    JointState m_qf;    //jointState_filtered(t)
//    JointState m_qf_1;  //jointState_filtered(t-1)
//    JointState m_qf_2;  //jointState_filtered(t-2)

    /*!
     * \brief m_ctrlIntf control interface type, this interface defines the type of
     * controller we are using, e.g. position control, velocity control, or torque control.
     */
    RobotControllers::ControlInterface m_ctrlIntf;

    /*!
     * \brief m_M Mass matrix (DOFxDOF)
     */
    MatrixDOFd m_M;
    /*!
     * \brief m_C Coriolis and Centripetal matrix (DOFxDOF)
     */
    MatrixDOFd m_C;

    /*!
     * \brief m_G Gravitational forces vector (DOFx1)
     */
    VectorDOFd m_G;

    /*!
     * \brief m_B Viscous friction matrix (DOFxDOF)
     */
    MatrixDOFd m_B;

    /*!
     * \brief m_tau Vector of generalized forces, usually generated by the controller (DOFx1)
     */
    VectorDOFd m_tau;

    /*!
     * \brief m_g_w gravitational vector (norm, e.g. directional vector) wrt world coordinate frame (wcf)
     */
    Vector3d m_g_w;

    /*!
     * \brief m_g_w gravitational vector (norm, e.g. directional vector) wrt robot base frame (wcf)
     */
    Vector3d m_g_0;

    /*!
     * \brief m_dynInitFlag Flag to initialize the variables of the dynamic model.
     */
    bool m_dynInitFlag;


    /*!
     * \brief m_controlPeriodMS control period in ms
     */
    double m_controlPeriodMS;   //[ms]
    /*!
     * \brief m_controlPeriod control period in s
     */
    double m_controlPeriod;     //[s]

    /*!
     * \brief m_controlPeriod_2 half of the control period
     */
    double m_controlPeriod_2;   //[s]

    /*!
     * \brief m_qpMax maximum joint velocity threshold, defined in the robot configuration file (config.ini)
     */
    double m_qpMax;

    /*!
     * \brief m_qMaxTotal maximum joint velocity generated in the robot.
     */
    double m_qMaxTotal;

    //for simplicity in the eqs I avoided m_

    /*!
     * \brief LX Offsets of all the joints, according to the DH tables (Joints and Center of Mases).
     */
    double L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12;

    /*!
     * \brief mX masses of all the joints.
     */
    double m1,m2,m3,m4,m5,m6;

    /*!
     * \brief IXij Inertia values of each link.
     */
    double I111,I112,I113,I122,I123,I133;
    double I211,I212,I213,I222,I223,I233;
    double I311,I312,I313,I322,I323,I333;
    double I411,I412,I413,I422,I423,I433;
    double I511,I512,I513,I522,I523,I533;
    double I611,I612,I613,I622,I623,I633;

    //double  u1_2,u1_4,u1_8,u1_16,u3_16,u1_32,u3_8,u3_4;
    /*!
     * \brief LX_2 half of offset LX.
     */
    double  L2_2,L3_2,L4_2,L5_2,L8_2,L9_2,L10_2,L11_2,L12_2;

    /*!
     * \brief m_Theta Vector of parameters (for the robot regressor).
     */
    VectorRegressor m_Theta;

    /*!
     * \brief m_Yr State Matrix (for the robot regressor).
     */
    MatrixRegressor m_Yr;

    //Filters

    /*!
     * \brief m_bfQ 2nd order Butterworth filter for the joint position q.
     */
    TButter2 m_bfQ;

    /*!
     * \brief m_bfQp 2nd order Butterworth filter for the joint velocity qp.
     */
    TButter2 m_bfQp;

    /*!
     * \brief m_bfQpp 2nd order Butterworth filter for the joint acceleration qpp.
     */
    TButter2 m_bfQpp;

    /*!
     * \brief m_bfCutof cutoff frequency used to initialize the filters. This parameter
     * is defined in the robot configuration file (config.ini)
     */
    double m_bfCutof;




    // Member functions
public:
    /*!
     * \brief DynamicModel Default constructor. This constructor parses the robot configuration file and
     * asigns the values of all the variables.
     * \param configFilePath Robot configuration file with absolute path.
     * \param kinematicModel pointer to the kinematicModel instance, usually generated by the RobotArm class.
     */
    DynamicModel(const QString &configFilePath, KinematicModel *kinematicModel);
    ~DynamicModel();

//    bool update(double time, const JointState &current);

    /*!
     * \brief update This function updates the state of the virtual robot, depending on the control interface
     * assigned to the controllers (m_ctrlIntf). If m_ctrlIntf is Position, then the output of the controler
     * (tau) is sent to the robot controller as commanded position. If m_ctrlIntf is Velocity, then the output of the controler
     * (tau) is sent to the robot controller as commanded velocity. The function will also compute
     * virtual joint position. Finally, if m_ctrlIntf is Effort, then the control output (tau) will be
     * cosidered as generalized forces. This function will compute the joint positions and velocities,
     * and use them as commanded values.
     * \param time current time. Usually this is a global time variable generated by the RobotArm main thread.
     * \param current current robot Joint state.
     * \return
     */
    bool update(const RobotTime& time, const JointState &current);


    /*!
     * \brief error access method for the error flag
     * \return it returns the error flag
     */
    bool error() const;

    /*!
     * \brief errorString gets the error description in a Qstring.
     * \return Qstring with the error description.
     */
    const QString& errorString() const;

    /*!
     * \brief qf access method for the filtered joint position
     * \return
     */
    const VectorDOFd& qf() const;
    /*!
     * \brief qpf access method for the filtered joint velocity
     * \return
     */
    const VectorDOFd& qpf() const;
    /*!
     * \brief qppf access method for the filtered joint acceleration
     * \return
     */
    const VectorDOFd& qppf() const;

    /*!
     * \brief q access method for the joint position
     * \return
     */
    const VectorDOFd& q() const;

    /*!
     * \brief qp access method for the joint velocity
     * \return
     */
    const VectorDOFd& qp() const;

    /*!
     * \brief qpp access method for the joint acceleration
     * \return
     */
    const VectorDOFd& qpp() const;

    /*!
     * \brief jointState access method for the current joint state
     * \return
     */
    const JointState& jointState() const;

    /*!
     * \brief jointState access method for the filtered joint state
     * \return
     */
    const JointState& jointStateF() const;

    /*!
     * \brief setCtrlInterface sets the control interface.
     * \param intf controller interface type for the entire robot. All the controllers
     * added to the Robot Arm class should be of the same tipe. This type is defined in
     * the robot configuration file (config.ini)
     * \return
     */
    bool setCtrlInterface(const RobotControllers::ControlInterface intf);

    /*!
     * \brief getCtrlInterface gets the control interface defined for the robot.
     * \return
     */
    const RobotControllers::ControlInterface getCtrlInterface() const;



    /*!
     * \brief setG_w Sets the direction of the gravitational acceleration wrt world coordiante frame.
     * \param g_w
     */
    void setG_w(const Vector3d& g_w);

    /*!
     * \brief setCtrlPeriod sets the control period, and computes the variables related to the control period.
     * \param ctrlP_ms desired control period in ms.
     */
    void setCtrlPeriod(double ctrlP_ms); //[ms]

    /*!
     * \brief setHistory function that updates the history variables of the robot joint state,
     * e.g., q, q_1, q_2, etc.
     */
    void setHistory();

    /*!
     * \brief setB generates the viscouse friction matrix as a diagonal matrix.
     * \param fricParam vector of diagonal matrix values.
     */
    void setB(const VectorDOFd& fricParam);


    /*!
     * \brief L gets a vector of all the robot offsets (kinematic and dynamic)
     * \return vector of robot offsets.
     */
    Vector12d L();

    /*!
     * \brief m gets a vector of all the robot link masses
     * \return vector of robot masses.
     */
    const VectorDOFd &m() const;

    /*!
     * \brief g0 gets vector of gravitational acceleration direction wrt robot base
     * \return vector of gravity direction wrt robot base
     */
    const Vector3d g0() const;

    /*!
     * \brief g gets the magnitud of the gravitational acceleration, e.g. 9.81 m/s*s
     * \return magnitud of gravitational acceleration
     */
    const double g() const;

    /*!
     * \brief g sets the magnitud of the gravitational acceleration, e.g. 9.81 m/s*s
     */
    void setAg( double g);

    /*!
     * \brief getCtrlPeriod get the control period defined to compute the direct dynamics
     * \return control period in s
     */
    const double getCtrlPeriod() const;


    /*!
     * \brief Yr Computes the state matrix (regressor matrix) using the current joint state,
     * it assumes that both the joint state (q) and the reference joint state (q_r) are the
     * current joint state of the robot.
     * \return Regressor Matrix (DOFXp)
     */
    const MatrixRegressor &Yr() const;

    /*!
     * \brief Yrc Computes the state matrix (regressor matrix) using the given joint state and
     * reference joint state.
     * \param js target joint state
     * \param js_r target reference joint state
     * \return Regressor Matrix (DOFXp)
     */
    const MatrixRegressor &Yrc(const JointState &js, const JointState &js_r);

    /*!
     * \brief YrcNoG Computes the state matrix (regressor matrix) using the given joint state and
     * reference joint state. This regressor doesn't have gravitational forces components.
     * \param js target joint state
     * \param js_r target reference joint state
     * \return Regressor Matrix (DOFXp)
     */
    const MatrixRegressor &YrcNoG(const JointState &js, const JointState &js_r);

    /*!
     * \brief Th gets the vector of robot paramters (px1) for the robot regressor.
     * \return vector of robot paramters
     */
    const VectorRegressor &Th() const;

    /*!
     * \brief M gets the Mass matrix using the current joint states
     * \return Mass matrix (DOFxDOF)
     */
    const MatrixDOFd &M() const;
    /*!
     * \brief C gets the Coriolis and Centripetal matrix using the current joint states
     * \return Coriolis and Centripetal forces matrix (DOFxDOF)
     */
    const MatrixDOFd &C() const;

    /*!
     * \brief B gets the viscous friction matrix
     * \return Friction matrix (DOFxDOF)
     */
    const MatrixDOFd &B() const;

    /*!
     * \brief G gets the gravitational forces vector using the current joint states
     * \return Gravitational forces vector (DOFx1)
     */
    const VectorDOFd &G() const;


    //This function set the init dynamics flag to false. Allows the initialization of vars

    /*!
     * \brief reinit This function set the init dynamics flag to false. Allows the initialization of
     * the class variables, for example, when the intitial condition of the itegral functions need to
     * be initialized.
     */
    void reinit();


    // Memeber Methods
private:

    /*!
     * \brief parseConfig function to parse the robot configuration file (config.ini), and
     * save all the robot paramters in their corresponding variables.
     * \param configFilePath robot configuration file with absolute path.
     * \return true if all the parameters could be parsed and saved.
     */
    bool parseConfig(const QString &configFilePath);

    /*!
     * \brief initParams sets all the parameters of the robot, e.g. Vector theta (robot regressor), and
     * initializes the Joint state filters.
     */
    void initParams();

    /*!
     * \brief updatePosition update function for Position interface. It assumes that
     * the control variable (tau) is the desired position.
     * \param time current time, usually generated by the robotArm thread.
     * \param current current joint state.
     * \return true if no errors are triggered.
     */
    bool updatePosition(const RobotTime& time, const JointState &current);

    /*!
     * \brief updateVelocity update function for Velocity interface. It assumes that
     * the control variable (tau) is the desired velocity. It computes the joint
     * position from the control joint velocity.
     * \param time current time, usually generated by the robotArm thread.
     * \param current current joint state.
     * \return true if no errors are triggered.
     */
    bool updateVelocity(const RobotTime& time, const JointState &current);

    /*!
     * \brief updateEffort update function for Effort interface. It assumes that
     * the control variable (tau) is the desired generalizd forces. It computes the joint
     * position and velocity from the control joint torque.
     * \param time current time, usually generated by the robotArm thread.
     * \param current current joint state.
     * \return true if no errors are triggered.
     */
    bool updateEffort(const RobotTime& time, const JointState &current);


    /*!
     * \brief Mc computes the Mass matrix given a specific joint state.
     * \param js joint state.
     * \return Mass matrix (DOFxDOF).
     */
    MatrixDOFd &Mc(const JointState &js);

    /*!
     * \brief Cc Computes the Coriolis and Centripetal forces matrix for a given joint state.
     * \param js joint state.
     * \return Coriolis and Centripetal forces matrix (DOFxDOF)
     */
    MatrixDOFd &Cc(const JointState &js);

    /*!
     * \brief Gc Computes the gravitational forces vector given a specific joint state
     * \param js joitn state
     * \return G vector (DOFx1)
     */
    VectorDOFd &Gc(const JointState &js);

};

}
}


















#endif // UR_ROBOT_LLI_DYNAMICS_H

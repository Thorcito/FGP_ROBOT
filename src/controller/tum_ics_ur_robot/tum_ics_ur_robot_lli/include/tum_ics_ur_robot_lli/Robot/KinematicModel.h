#ifndef KINEMATICS_H
#define KINEMATICS_H

/* Kinematic Models class
 * Authors: Emmanuel Dean and Florian Bergner
 * email: dean@tum.de, florian.bergner@tum.de
 *
 * v1: 2015
 */
#include<ros/ros.h>

//TF
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <tf_conversions/tf_eigen.h>


#include<tumtools/Math/MathTools.h>

#include<tum_ics_ur_robot_lli/JointState.h>
#include<tum_ics_ur_robot_lli/RobotTime.h>

namespace tum_ics_ur_robot_lli{
namespace Robot{

/*!
 * \brief The KinematicModel class This class provides useful functions to compute the robot kinematic models, e.g.
 * Homogeneous Transformations, Jacobians, FK, etc. This class uses
 * the kinematic parameters provided in the robot configuration file (config.ini).
 */
class KinematicModel: public Tum::Tools::MathTools
{
    // Member variables
private:

    /*!
     * \brief m_node ros node handler used to publish FK data, e.g. Pose of the end-effector wrt robot base link.
     */
    ros::NodeHandle m_node;

    /*!
     * \brief m_pubEFPose_0 ros publisher for the end-effector pose wrt robot base link.
     */
    ros::Publisher m_pubEFPose_0;

    /*!
     * \brief m_pubEFPose_w ros publisher for the end-effector pose wrt world coordinate frame.
     */
    ros::Publisher m_pubEFPose_w;

    /*!
     * \brief m_pubEFPose_w_real publisher for the end-effector pose wrt world coordinate frame, usign the
     * real-robot joint state.
     */
    ros::Publisher m_pubEFPose_w_real;

    /*!
     * \brief m_publishEfFlag Flag to toggle on/off the publisers. True = publish data, False=no publishers.
     * The flag is set to true by default.
     */
    bool m_publishEfFlag;

    /*!
     * \brief m_errorString variable to store the text description of an error triggered in the class.
     */
    QString m_errorString;

    /*!
     * \brief m_error error flag, used for example to stop all the threads of the robotArm class.
     */
    bool m_error;

    /*!
     * \brief m_groupName defines if the robot should be considered left, right, or none. This variable
     * is used to publish the additional robot tfs, e.g. the DH coordinate frames generated by the FK functions.
     */
    QString m_groupName;

    /*!
     * \brief m_namePrefix short string to preappend to the tfs names, e.g. "l", "r", or "dh".
     */
    QString m_namePrefix;

    /*!
     * \brief m_baseName defines the name of the tf that should be used as parent for all the tfs generated
     * by the FK functions.
     */
    QString m_baseName;

    /*!
     * \brief m_l vector of all the kinematic offsets (from the DH table)
     */
    Vector7d m_l;

    /*!
     * \brief m_T0_w Homogeneous transformation of the robot base wrt the world coordinate frame.
     */
    Affine3d m_T0_w; //HTransform robot base wrt world cf

    /*!
     * \brief m_Tw_0 Homogeneous transformation of the world coordiante frame wrt the robot base.
     */
    Affine3d m_Tw_0;

    /*!
     * \brief m_q virtual robot joint state.
     */
    JointState m_q;

    /*!
     * \brief m_Ti_0 Array of Homogeneous transformations of all the robot links wrt the robot base (link 0)
     */
    VAffine3d m_Ti_0;

    /*!
     * \brief m_Ti_0 Array of Homogeneous transformations of all the robot links wrt the robot base (link 0). This
     * matrices are generated with a predicted value of the joint position = joint position + joint velocity*dt
     */
    VAffine3d m_Ti_0_pred;


    /*!
     * \brief m_br TrasformBroadcaster to publish all the tf generated by this class, e.g. end-effector, dh coordinate
     * frames, etc.
     */
    tf::TransformBroadcaster m_br;

    /*!
     * \brief LX robot kinematic offsets.
     */
    double L1,L2,L3,L4,L5,L6;

    /*!
     * \brief LX_2 square of robot kinematic offsets.
     */
    double L2_2,L3_2,L4_2,L5_2;

    //End-effector Data wrt 0
    /*!
     * \brief m_Tef_0 Current Homogeneous transformation of the end-effector wrt the robot base (link 0).
     */
    Affine3d m_Tef_0;

    /*!
     * \brief m_xef_0 Current Position (3X1) of the end-effector wrt the robot base (link 0).
     */
    Vector3d m_xef_0;

    /*!
     * \brief m_Ref_0 Current Orientation matrix (3x3) of the end-effector wrt the robot base (link 0).
     */
    Matrix3d m_Ref_0;

    /*!
     * \brief m_Jef_0 Current Jacobian matrix (6xDOF) of the end-effector wrt the robot base (link 0).
     */
    MatrixJd m_Jef_0;

     //End-effector Data wrt base_link
    /*!
     * \brief m_Tef_w Current Homogeneous transformation of the end-effector wrt the world coordinate frame (wcf).
     */
    Affine3d m_Tef_w;

    /*!
     * \brief m_xef_w Current Position (3X1) of the end-effector wrt the world coordinate frame (wcf).
     */
    Vector3d m_xef_w; //Position of ef wrt 0 3D

    /*!
     * \brief m_Ref_w Current Orientation matrix (3x3) of the end-effector wrt the world coordinate frame (wcf).
     */
    Matrix3d m_Ref_w;


    /*!
     * \brief m_Xefp_0 End-effector velocity vector (6x1) [linear and angular] wrt the robot base (link 0).
     */
    Vector6d m_Xefp_0;

    /*!
     * \brief m_xefp_0 End-effector linear velocity vector (3x1) wrt the robot base (link 0).
     */
    Vector3d m_xefp_0;

    /*!
     * \brief m_wefp_0 End-effector angular velocity vector (3x1) wrt the robot base (link 0).
     */
    Vector3d m_wefp_0;

    /*!
     * \brief m_xefp_w End-effector linear velocity vector (3x1) wrt the world coordiante frame (wcf).
     */
    Vector3d m_xefp_w;


    /*!
     * \brief m_x_j_0 Array of x-axis of each link coordinate frame. The first vector is the robot base link x-axis,
     * i.e. the array has a size DOF+1 with j = [0] base, [1] link 1,..., [DOF] link EF.
     */
    VVector3d m_x_j_0;

    /*!
     * \brief m_y_j_0 Array of y-axis of each link coordinate frame. The first vector is the robot base link y-axis,
     * i.e. the array has a size DOF+1 with j = [0] base, [1] link 1,..., [DOF] link EF.
     */
    VVector3d m_y_j_0;

    /*!
     * \brief m_z_j_0 Array of x-axis of each link coordinate frame. The first vector is the robot base link z-axis,
     * i.e. the array has a size DOF+1 with j = [0] base, [1] link 1,..., [DOF] link EF.
     */
    VVector3d m_z_j_0;

    /*!
     * \brief m_x_j_0 Array of position vectors of each link coordinate frame wrt the robot base.
     * The first vector is the robot base position, i.e. the array has a size DOF+1 with
     * j = [0] base, [1] link 1,..., [DOF] link EF.
     */
    VVector3d m_t_j_0;


    /*!
     * \brief m_TIdentity Homogeneous transformation without rotation and zero position (Identity matrix 4x4)
     */
    const Affine3d m_TIdentity;


    // Member functions
public:

    /*!
     * \brief KinematicModel Defaul constructor. The cosntructor parses the robot configuration file (config.ini)
     * and saves the kinematic parameters in their corresponding variables. It initializes all the publishers, and
     * allocate the space for all the Arrays, e.g. Homogeneous Transformations array.
     * \param configFilePath robot configuration file name with absolute path.
     * \param groupName variable that defines if the robot should be considered left, right, or generic (dh). This
     * parameter is defined in the robot configuration file (config.ini).
     * \param robotDescription Currently not used!!!!
     */
    KinematicModel(const QString &configFilePath, const QString &groupName="none", const QString &robotDescription="robot_description");
    ~KinematicModel();

    // joint name prefix for dh joints
    void setNamePrefix(const QString& namePrefix);

    /*!
     * \brief error access method for the error flag
     * \return it returns the error flag
     */
    bool error();

    /*!
     * \brief errorString gets the error description in a Qstring.
     * \return Qstring with the error description.
     */
    const QString& errorString();

    /*!
     * \brief update This function updates the internal joint position q and updates all the kinematic models,
     * Homogeneous transformations, end-effector poses, velcities, and jacobian matrix, etc. It calls internally
     * the functions updateTi_0, updateTi_0_pred, UpdateJointAxes_0,updateEFState. Usually, this function is called
     * in the main thread of the RobotArm class.
     * \param time current robot time.
     * \param current current joint state.
     * \return true if all the models where succsessfully updated.
     */
    bool update(const RobotTime& time, const JointState &current);


    /*!
     * \brief setT0_W sets the Homogeneous transformation of the robot base link (link 0) wrt the world coordinate frame.
     * \param Twcf Homogeneous transformation (4x4) base wrt world.
     */
    void setT0_W(const Affine3d& Twcf=Affine3d::Identity());

    /*!
     * \brief T0_w gets the Homogeneous transformation of the robot base link (link 0) wrt the world coordinate frame.
     * \return Homogeneous Transformation (4x4) of base wrt world.
     */
    const Affine3d& T0_w() const;

    /*!
     * \brief T0_w gets the Homogeneous transformation of the world coordinate frame wrt the robot base link (link 0).
     * \return Homogeneous Transformation (4x4) of world wrt base.
     */
    const Affine3d& Tw_0() const;


    /*!
     * \brief L gets a vector with all the kinematic offsets (d and a from DH table)
     * \return vector (7x1) with joint lenght offsets
     */
    const Vector7d& L() const;


    /*!
     * \brief Ti_0 gets the Homogeneous transformation of the link i of the robot
     * \param jointID link number, the links are numbered from 0 to 6, where 0 corresponds to the robot base (link 0) and
     * 6 corresponds to the robot end-effector.
     * \return Homogeneous Transformation (4x4) of the link jointID.
     */
    const Affine3d& Ti_0(uint jointID) const;

    /*!
     * \brief Ti_0 gets the predicted Homogeneous transformation of the link i of the robot. The prediction is
     * based on the current joint velocity, i.e. q_pred=q+qp*dt
     * \param jointID link number, the links are numbered from 0 to 6, where 0 corresponds to the robot base (link 0) and
     * 6 corresponds to the robot end-effector.
     * \return Homogeneous Transformation (4x4) of the link jointID.
     */
    const Affine3d& Ti_0_pred(uint jointID) const;

    /*!
     * \brief Zi_0 gets the z-axis of the link i.
     * \param jointID link number, the links are numbered from 0 to 6, where 0 corresponds to the robot base (link 0) and
     * 6 corresponds to the robot end-effector.
     * \return z-axis vector (3x1) of the link jointID.
     */
    Vector3d Zi_0(uint jointID) const;

    /*!
     * \brief Pi_0 gets the position vector of the link i.
     * \param jointID link number, the links are numbered from 0 to 6, where 0 corresponds to the robot base (link 0) and
     * 6 corresponds to the robot end-effector.
     * \return position vector (3x1) of the link jointID.
     */
    Vector3d Pi_0(uint jointID) const;

    /*!
     * \brief JSingleL Computes the Jacobian matrix of a point p (3x1) connected to the first joint only.
     * \param pi_0 position of the point p (3x1) wrt to the robot base (link 0)
     * \return Jacobian matrix (6xDOF) with all the columns zero(6x1) except the first column.
     */
    MatrixJvd JSingleL(Vector3d &pi_0);


    /*!
     * \brief JLi_0 Computes the Jacobian matrix of a point p (3x1) connected to the link l.
     * \param pi_0 position of the point p (3x1) wrt the robot base (link 0).
     * \param link robot link where the point p is connected to.
     * \return Jacobian Matrix (6xDOF). If the link is the robot base (link=0), then the Jacobian matrix is zero(6xDOF).
     * TODO: add a Jacobian function using local position, i.e. pi_l
     */
    MatrixJd JLi_0(Vector3d& pi_0, uint link);

    /*!
     * \brief JLi_0 Computes the Jacobian matrix of a homogeneous point p=[px,py,pz,1] (4x1) connected to the link l.
     * \param pi_0 homogeneous position of the point p (4x1) wrt the robot base (link 0).
     * \param link robot link where the point p is connected to.
     * \return Jacobian Matrix (6xDOF). If the link is the robot base (link=0), then the Jacobian matrix is zero(6xDOF).
     */
    MatrixJd JLi_0(Vector4d& pi_0, uint link);

    /*!
     * \brief Jef_0 Computes the Jacobian of the end-effector wrt the robot base (link 0), using a given joint position.
     * \param qc target joint position vector (DOFx1).
     * \return Jacobian matrix of the end_effector (6xDOF)
     */
    MatrixJd Jef_0(const VectorDOFd &qc);

    /*!
     * \brief Tef_0 Computes the Homogeneous transformation of the end-effector wrt the robot base (link 0), using
     * a given joint position vector.
     * \param qc target joint position vector (DOFx1).
     * \return Homogeneous Transformation of the end-effector (4x4).
     */
    Affine3d Tef_0(const VectorDOFd &qc);

    /*!
     * \brief updateTi_0 Populates an array with all the homogenesous transformations of the robot links, using a given
     * joint position vector.
     * \param qc target joint position vector (DOFx1).
     * \return inT Array of Homogeneous transformations. This variable has to be passed as reference to the funciton.
     */
    void updateTi_0(VAffine3d &inT, const VectorDOFd &qc); //compute all joint TH


    /*!
     * \brief Tef_0 gets the current homogeneous transformation of the end-effector wrt robot base (link 0).
     * \return Homogeneous transformation end-effector (4x4).
     */
    const Affine3d& Tef_0() const;

    /*!
     * \brief xef_0 gets the current position vector of the of the end-effector wrt robot base (link 0).
     * \return position vector of the end-effector (3x1).
     */
    const Vector3d& xef_0() const;

    /*!
     * \brief Ref_0 gets the current orientation matrix of the end-effector wrt robot base (link 0).
     * \return Rotation matrix of end-effector (3x3).
     */
    const Matrix3d& Ref_0() const;

    /*!
     * \brief Tef_w gets the current homogeneous transformation matrix of the end-effector wrt the world coordiante frame (wcf).
     * \return Homogeneous transformation end-effector (4x4).
     */
    const Affine3d& Tef_w() const;

    /*!
     * \brief xef_w gets the current position vector of the of the end-effector wrt the world coordiante frame (wcf).
     * \return position vector of the end-effector (3x1).
     */
    const Vector3d& xef_w() const;

    /*!
     * \brief Ref_w gets the current orientation matrix of the end-effector wrt world coordiante frame (wcf).
     * \return Rotation matrix of end-effector (3x3).
     */
    const Matrix3d& Ref_w() const;


    /*!
     * \brief FK gets the Homogeneous transformation of the last link wrt the robot base (link 0)
     * \return Homogeneous transformation (4x4) of the last link.
     */
    const Affine3d &FK() const;

    /*!
     * \brief Jef_0 gets the Jacobian matrix of the end-effector wrt the robot base (link 0).
     * \return Jacobian matrix of the end-effector (6xDOF).
     */
    const MatrixJd& Jef_0() const;

    /*!
     * \brief Xefp_0 gets the end-effector velocity vector (linear and angular) wrt robot base.
     * \return velocity vector of the end-effector (6X1).
     */
    const Vector6d& Xefp_0() const;

    /*!
     * \brief xefp_0 gets the linear velocity vector of the end-effector wrt the robot base.
     * \return linear velocity vector of the end-effector (3x1).
     */
    const Vector3d& xefp_0() const;

    /*!
     * \brief wefp_0 gets the angular velocity vector of the end-effector wrt the robot base.
     * \return Angular velocity vector of the end-effector (3x1).
     */
    const Vector3d& wefp_0() const;

    /*!
     * \brief xefp_w gets the linear velocity vector of the end-effector wrt the world coordinate frame.
     * \return linear velocity vector of the end-effector (3x1).
     */
    const Vector3d& xefp_w() const;


    // j = 0, ..., 6

    /*!
     * \brief T_j_0 gets the Homogeneous transformation of the link j wrt the robot base (link 0),
     * where j=0 is the base link wrt itself.
     * \param j target link, j=0,1,...,DOF.
     * \return Homogeneous transformation of link j (4x4).
     */
    const Eigen::Affine3d& T_j_0(int j) const;

    /*!
     * \brief x_j_0 gets the x-axis of the link j wrt the robot base (link 0),
     * where j=0 is the base link wrt itself.
     * \param j target link, j=0,1,...,DOF.
     * \return x-axis (3x1) of link j.
     */
    const Eigen::Vector3d& x_j_0(int j) const;
     /*!
     * \brief y_j_0 gets the y-axis of the link j wrt the robot base (link 0),
     * where j=0 is the base link wrt itself.
     * \param j target link, j=0,1,...,DOF.
     * \return y-axis (3x1) of link j.
     */
    const Eigen::Vector3d& y_j_0(int j) const;
     /*!
     * \brief z_j_0 gets the z-axis of the link j wrt the robot base (link 0),
     * where j=0 is the base link wrt itself.
     * \param j target link, j=0,1,...,DOF.
     * \return z-axis (3x1) of link j.
     */
    const Eigen::Vector3d& z_j_0(int j) const;
     /*!
     * \brief t_j_0 gets the position vector of the link j wrt the robot base (link 0),
     * where j=0 is the base link wrt itself.
     * \param j target link, j=0,1,...,DOF.
     * \return position vector (3x1) of link j.
     */
    const Eigen::Vector3d& t_j_0(int j) const;

    /*!
     * \brief publish_FK publishes topics and tfs related to the FK of the robot, using thye current joint state.
     */
    void publish_FK();

    /*!
     * \brief publish_FK publishes topics and tfs related to the FK of the robot, using the target joint position.
     * The topic name is the one defined for m_pubEFPose_w_real publisher.
     * \param qc target joint position.
     * \param posfix string to be added to the tf.
     */
    void publish_FK(const VectorDOFd &qc, const std::string &posfix);




    // Memeber Methods
private:
    /*!
     * \brief parseConfig parses the robot configuration file (config.ini) to extract the parameters and save them in
     * the local variables.
     * \param configFilePath robot configuration file name with absolute path.
     * \return true if the parsing was succsessful.
     */
    bool parseConfig(const QString &configFilePath);

    /*!
     * \brief initParams sets LX and LX_2 from the loaded paramters.
     */
    void initParams();

    /*!
     * \brief updateTi_0 updates all the Homogeneaous transformations of the robot using the current joint state.
     */
    void updateTi_0(); //compute all joint TH at time t

    /*!
     * \brief updateTi_0_pred updates all the predicted Homogeneaous transformations of the robot using
     * the current joint state. The prediction is based on the joint velocity, q_pred=q+qp*dt.
     */
    void updateTi_0_pred();

    /*!
     * \brief updateEFState updates all the kinematic models of the end-effector using the current joint state.
     */
    void updateEFState();

    /*!
     * \brief updateJef_0 updates the jacbian of the end-effector using the current joint state.
     */
    void updateJef_0();

    /*!
     * \brief updateJointAxes_0 updates the joint axis using the current joint state.
     */
    void updateJointAxes_0();
};



}
}

#endif // KINEMATICS_H

